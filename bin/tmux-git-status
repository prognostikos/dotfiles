#!/bin/bash
set -euo pipefail

# Prevent lock conflicts with other git operations (rebase, merge, etc.)
# This tells git to skip optional operations that require index.lock
export GIT_OPTIONAL_LOCKS=0

# Exit early if not in a git repo
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
  exit 0
fi

# Get branch name and action state
branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")
action=""

# Check for ongoing git actions
git_dir=$(git rev-parse --git-dir 2>/dev/null)
if [ -n "$git_dir" ]; then
  if [ -f "$git_dir/rebase-merge/interactive" ]; then
    action="+rebase-i"
  elif [ -d "$git_dir/rebase-merge" ]; then
    action="+rebase-m"
  elif [ -d "$git_dir/rebase-apply" ]; then
    if [ -f "$git_dir/rebase-apply/rebasing" ]; then
      action="+rebase"
    elif [ -f "$git_dir/rebase-apply/applying" ]; then
      action="+am"
    else
      action="+am/rebase"
    fi
  elif [ -f "$git_dir/MERGE_HEAD" ]; then
    action="+merge"
  elif [ -f "$git_dir/CHERRY_PICK_HEAD" ]; then
    action="+cherry-pick"
  elif [ -f "$git_dir/REVERT_HEAD" ]; then
    action="+revert"
  elif [ -f "$git_dir/BISECT_LOG" ]; then
    action="+bisect"
  fi
fi

# Initialize status indicators
staged=""
unstaged=""
untracked=""
unpushed=""

# Get status information
while IFS= read -r line; do
  status="${line:0:2}"

  # Check for staged changes (first character)
  case "${status:0:1}" in
    M|A|D|R|C)
      if [[ ! "$staged" =~ A ]]; then
        staged="#[fg=green,bold]A#[nobold]"
      fi
      ;;
  esac

  # Check for unstaged changes (second character)
  case "${status:1:2}" in
    M|D)
      if [[ ! "$unstaged" =~ M ]]; then
        unstaged="#[fg=red,bold]M#[nobold]"
      fi
      ;;
  esac

  # Check for untracked files
  if [[ "$status" == "??" ]]; then
    if [[ ! "$untracked" =~ "??" ]]; then
      untracked="#[fg=blue,bold]??#[nobold]"
    fi
  fi
done < <(git status --porcelain 2>/dev/null)

# Check for unpushed commits
if git rev-parse --abbrev-ref '@{upstream}' &>/dev/null; then
  ahead=$(git rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo "0")
  if [[ "$ahead" -gt 0 ]]; then
    unpushed="#[fg=magenta,bold]â†‘#[nobold]"
  fi
fi

# Build status string
status_str="${staged}${unstaged}${untracked}${unpushed}"

# Format output
if [[ -n "$status_str" ]]; then
  echo "#[fg=cyan,bold]${branch}${action}#[fg=cyan] ${status_str}"
else
  echo "#[fg=cyan,bold]${branch}${action}#[fg=cyan]"
fi
